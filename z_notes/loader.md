# cpu的段页门 特权级

    1. seg(段) or sel(选择子) + offset ---> 虚拟地址 --->  MCU  ->  物理地址
    2.中断门 陷阱门 调用门 任务门
        - 中断门和陷阱门仍在64位系统中使用。
        - 调用门和任务门基本被淘汰，现代系统采用了更高效的替代机制。
    3.特权级：0-->内核态    3--->用户态    1 2一般用于虚拟化，虽然权限比内核低，但是比用户态高，可用虚拟化一些操作

# cpu保护模式
    1.开启分页机制  GDT IDT表
    2.32位系统，每个进程共享4GB虚拟内存。64位系统通常只用48位虚拟地址，支持2^48 = 256T的虚拟空间，用户和内核各占128T
    3.PAE是一种用于32位系统的技术。虚拟地址空间扔是4GB，但是物理内存可以支持到64G，启用了3级页表，原本是2级页表。

# cpu兼容模式 (64位模式)
    1.ia32-e  64位模式下可以运行32位程序
    2.开启4级页表

# 64位长模式
    48位虚拟地址 52位物理地址
    某些处理器引入了5级页表，48位虚拟地址扩展至57位


# GDT描述符
    63          56 55 52 51         48 47    40 39       32   31         16 15           0
    +-------------+-----+-------------+--------+-------------+-------------+-------------+
    | Base High   |Flags| Limit High  | Access | Base Middle | Base Low    | Limit Low   |
    | (8 bits)    |(4b) | (4 bits)    | Byte   | (8 bits)    | (16 bits)   | (16 bits)   |
    |             |     |             | (8b)   |             |             |             |
    +-------------+-----+-------------+--------+-------------+-------------+-------------+

    基地址：32位
    段界限：20位， limit= size - 1    
        如果粒度（Granularity）为0，段限长以字节为单位（最大1 MB）。
        如果粒度为1，段限长以4 KB为单位（最大4 GB）。
            - 例如0x10000设置段界限大小为1MB， limit = 0x10000-1 = 0xFFFF
            - 一般配置为0xFFFF,粒度设置为1，表示该段的范围是0~4GB

    GDTR寄存器：GDTR是一个48位的寄存器，包含16位的界限(0~15位)和32位的基地址(16~47位)。
                界限: limit = 表大小(单位:字节) - 1
                基地址:GDT表首地址
                GP异常  一般性保护性异常，一般都是GDT描述符出错了
    CPL DPL RPL

# 进入保护模式
    1.cli;关中断
    2.加载GDT表
    3.开A20地址总线，cpu可以访问1MB以上内存
        通过系统控制寄存器，访问其0x92端口
        从0x92端口读取1字节
        将该字节与0x01与运算(设置最低位为1)
        将结果写会0x92

        关闭A20自然是清楚最低位
    4.打开保护模式 设置CR0 的PE位
    5.远跳转 进入32位保护模式代码
    6.初始化段寄存器，cs ds ...  注：cs只能通过jmp ljmp ljmpl等跳转指令进行赋值，不能直接mov $0,%cs , 其他可以
    7.开启页表，初始化页表，可用设置成128M内存全覆盖。
    8.重新设置内核栈，设置esp
    9.加载并进入内核，可以根据需求自己设定页表
    10.设置IDT表，开启中断


# 控制寄存器 

## cr0
---

    ### **CR0寄存器结构**
    CR0是一个32位寄存器（在64位模式下仍然是32位），其结构如下：

    | 位范围 | 位名称            | 描述                                                                 |
    |--------|-------------------|----------------------------------------------------------------------|
    | 0      | **PE（Protection Enable）** | 启用保护模式（1）或实模式（0）。                                     |
    | 1      | **MP（Monitor Coprocessor）** | 监控协处理器（与浮点指令相关）。                                     |
    | 2      | **EM（Emulation）** | 启用浮点单元仿真（1）或使用硬件浮点单元（0）。                       |
    | 3      | **TS（Task Switched）** | 任务切换标志，用于延迟浮点上下文切换。                               |
    | 4      | **ET（Extension Type）** | 扩展类型（在386中用于指示协处理器类型，现代系统中通常为1）。         |
    | 5      | **NE（Numeric Error）** | 启用浮点错误处理（1）或禁用（0）。                                   |
    | 16     | **WP（Write Protect）** | 写保护，禁止内核写入只读页面（1）或允许（0）。                       |
    | 18     | **AM（Alignment Mask）** | 启用对齐检查（1）或禁用（0）。                                       |
    | 29     | **NW（Not Write-through）** | 禁用写透缓存（1）或启用（0）。                                       |
    | 30     | **CD（Cache Disable）** | 禁用缓存（1）或启用（0）。                                           |
    | 31     | **PG（Paging Enable）** | 启用分页机制（1）或禁用（0）。                                       |

    ---
## cr1
    保留，没用
    访问会报异常，UD异常(无效的操作码)，
## cr2
    存放PE 页错误的错误地址
    64位模式下，也能扩展为64位

## cr3
    存放页表首地址(页目录地址)
## cr4

CR4是一个32位寄存器（在64位模式下仍然是32位），其结构如下：

    | 位范围 | 位名称            | 描述                                                                 |
    |--------|-------------------|----------------------------------------------------------------------|
    | 0      | **VME（Virtual 8086 Mode Extensions）** | 启用虚拟8086模式扩展（1）或禁用（0）。                               |
    | 1      | **PVI（Protected Mode Virtual Interrupts）** | 启用保护模式虚拟中断（1）或禁用（0）。                               |
    | 2      | **TSD（Time Stamp Disable）** | 禁用RDTSC指令（1）或允许（0）。                                      |
    | 3      | **DE（Debugging Extensions）** | 启用调试扩展（1）或禁用（0）。                                       |
    | 4      | **PSE（Page Size Extensions）** | 启用4 MB大页（1）或禁用（0）。                                       |
    | 5      | **PAE（Physical Address Extension）** | 启用物理地址扩展（1）或禁用（0）。                                   |
    | 6      | **MCE（Machine Check Enable）** | 启用机器检查异常（1）或禁用（0）。                                   |
    | 7      | **PGE（Page Global Enable）** | 启用全局页（1）或禁用（0）。                                         |
    | 8      | **PCE（Performance Monitoring Counter Enable）** | 启用性能监控计数器（1）或禁用（0）。                                 |
    | 9      | **OSFXSR（Operating System Support for FXSAVE and FXRSTOR）** | 启用FXSAVE/FXRSTOR指令（1）或禁用（0）。                             |
    | 10     | **OSXMMEXCPT（Operating System Support for Unmasked SIMD Floating-Point Exceptions）** | 启用SIMD浮点异常（1）或禁用（0）。                                   |
    | 13     | **VMXE（VMX Enable）** | 启用Intel VT-x虚拟化技术（1）或禁用（0）。                            |
    | 14     | **SMXE（SMX Enable）** | 启用Intel SMX安全扩展（1）或禁用（0）。                               |
    | 16     | **FSGSBASE（FS/GS Base Access）** | 启用FS/GS基址寄存器访问指令（1）或禁用（0）。                         |
    | 17     | **PCIDE（PCID Enable）** | 启用进程上下文标识符（PCID）（1）或禁用（0）。                        |
    | 18     | **OSXSAVE（OS Support for XSAVE and Processor Extended States）** | 启用XSAVE指令集（1）或禁用（0）。                                     |
    | 20     | **SMEP（Supervisor Mode Execution Prevention）** | 启用内核模式执行保护（1）或禁用（0）。                                |
    | 21     | **SMAP（Supervisor Mode Access Prevention）** | 启用内核模式访问保护（1）或禁用（0）。                                |
    | 22     | **PKE（Protection Key Enable）** | 启用内存保护键（1）或禁用（0）。                                      |

    ---
# 内存检测
    BIOS 0x15 0xe820

    Address Range Descriptor Structure ARDS

    | 字节偏移量 | 属性名称     | 描述                             |
    | ---------- | ------------ | -------------------------------- |
    | 0          | BaseAddrLow  | 基地址的低 32 位                 |
    | 4          | BaseAddrHigh | 基地址的高 32 位                 |
    | 8          | LengthLow    | 内存长度的低 32 位，以字节为单位 |
    | 12         | LengthHigh   | 内存长度的高 32 位，以字节为单位 |
    | 16         | Type         | 本段内存的类型                   |

    ## Type 字段

    | Type 值 | 名称                 | 描述                                                                                 |
    | ------- | -------------------- | ------------------------------------------------------------------------------------ |
    | 1       | AddressRangeMemory   | 这段内存可以被操作系统使用                                                           |
    | 2       | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以用此内存                                     |
    | 3       |                      | 存储ACPI表，可以被操作系统回收。|
    | 4       |                      | 操作系统不可使用这段内存。|
    | 5       |                      | 已经损坏的内存区域，不可使用。|
    | 其他    | 未定义               | 未定义，将来会用到．目前保留． 但是需要操作系统一样将其视为ARR(AddressRangeReserved) |


    ## 调用前输入

    | 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                                                                                 |
    | -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | EAX            | 子功能号： EAX 寄存器用来指定子功能号，此处输入为 0xE820                                                                                                                                                                                                                                                 |
    | EBX            | 内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉 BIOS 该返回哪个 ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现，每次中断返回后，BIOS 会更新此值 |
    | ES: DI         | ARDS 缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以 ARDS 格式返回                                                                                                                                                                                                                       |
    | ECX            | ARDS 结构的字节大小：用来指示 BIOS 写入的字节数。调用者和 BIOS 都同时支持的大小是 20 字节，将来也许会扩展此结构                                                                                                                                                                                          |
    | EDX            | 固定为签名标记 `0x534d4150`，此十六进制数字是字符串 `SMAP` 的ASCII 码： BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息                                                                                                                                 |

    ## 返回值

    | 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                   |
    | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | CF 位          | 若CF 位为 0 表示调用未出错，CF 为1，表示调用出错                                                                                                                                                                                           |
    | EAX            | 字符串 SMAP 的 ASCII 码 `0x534d4150`                                                                                                                                                                                                       |
    | ES:DI          | ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被BIOS 填充了内存信息                                                                                                                                                                 |
    | ECX            | BIOS 写入到 ES:DI 所指向的 ARDS 结构中的字节数，BIOS 最小写入 20 字节                                                                                                                                                                      |
    | EBX            | 后续值：下一个 ARDS 的位置。每次中断返回后，BIOS 会更新此值， BIOS 通过此值可以找到下一个待返回的 ARDS 结构，咱们不需要改变 EBX 的值，下一次中断调用时还会用到它。在 CF 位为 0 的情况下，若返回后的 EBX 值为 0，表示这是最后一个 ARDS 结构 |


# 错误总结
    1.汇编中可以包含头文件，但是头文件中必须是简单的宏定义，不能有其他的东西
    2..code16 这种东西要放在头文件上面
    3. .data .bss写在.text下面
    4. 必须得是 ld a.o b.o -o main.elf -L path/to/lib -l mylib,有时候把-L -l放前面就不行，
    